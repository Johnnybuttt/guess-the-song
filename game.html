<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://sdk.scdn.co; style-src 'self' 'unsafe-inline'; connect-src https://accounts.spotify.com https://api.spotify.com; frame-src https://accounts.spotify.com; object-src 'none'; base-uri 'self';">
  <title>Guess The Song</title>
  <link rel="stylesheet" href="app.css">
</head>
<body>
<div class="container">
  <h1>Guess The Song</h1>

  <div class="card">
    <div class="kpi">
      <div><b>Round</b><div id="roundLabel" class="small">0 / 0</div></div>
      <div><b>Time</b><div id="timer" class="small">—</div></div>
      <div><b>Score</b><div id="score" class="small">0</div></div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <button id="loginBtn" class="secondary">Login Spotify</button>
      <button id="initBtn" disabled>Initialize Player</button>
      <button id="shuffleBtn" class="secondary" disabled>Shuffle More</button>
      <button id="playBtn" disabled>Play Round</button>
      <button id="skipBtn" class="secondary" disabled>Skip</button>
      <button id="quitBtn" class="secondary">Change Settings</button>
    </div>

    <div class="hr"></div>

    <p id="status" class="small">—</p>

    <div class="row">
      <input id="guess" placeholder="Type the full song title…" disabled autocomplete="off">
      <button id="submit" disabled>Submit</button>
    </div>

    <p id="result"></p>
  </div>
</div>

<!-- Spotify SDK callback -->
<script>
  window.__sdkReady = false;
  window.onSpotifyWebPlaybackSDKReady = () => {
    window.__sdkReady = true;
    document.getElementById("initBtn").disabled = false;
    document.getElementById("status").textContent =
      "Spotify SDK loaded. Click Initialize Player.";
  };
</script>

<!-- Note: SRI (Subresource Integrity) would require fetching the script and generating a hash.
     Since Spotify may update their SDK, SRI is not practical here. CSP provides protection instead. -->
<script src="https://sdk.scdn.co/spotify-player.js"></script>

<script type="module">
  import { beginLogin, isAuthed, getAccessToken, spotifyFetch } from "./spotify.js";

  const roundsTotal = Number(localStorage.getItem("rounds") || 10);
  const clipSeconds = Number(localStorage.getItem("clip") || 30);
  const songPool = localStorage.getItem("song_pool") || "top"; // top | random

  const loginBtn = document.getElementById("loginBtn");
  const initBtn = document.getElementById("initBtn");
  const shuffleBtn = document.getElementById("shuffleBtn");
  const playBtn = document.getElementById("playBtn");
  const skipBtn = document.getElementById("skipBtn");
  const quitBtn = document.getElementById("quitBtn");
  const statusEl = document.getElementById("status");
  const roundLabel = document.getElementById("roundLabel");
  const timerEl = document.getElementById("timer");
  const scoreEl = document.getElementById("score");
  const guessEl = document.getElementById("guess");
  const submitBtn = document.getElementById("submit");
  const resultEl = document.getElementById("result");

  let player, deviceId;
  let tracks = [], current = null;
  let round = 0, score = 0;
  let timer = null, active = false;

  /* ---------------- helpers ---------------- */

  const sleep = ms => new Promise(r => setTimeout(r, ms));

  async function waitForActiveDevice(timeout = 10000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      try {
        const state = await spotifyFetch("/me/player");
        if (state?.device?.id === deviceId && state?.device?.is_active) return true;
      } catch (e) {
        // Device might not be ready yet, continue waiting
        console.log("Waiting for device to become active...");
      }
      await sleep(500);
    }
    throw new Error("Device did not become active in time. Please try initializing the player again.");
  }

  function normalizeTitle(s) {
    let t = (s || "").toLowerCase().trim();
    t = t.split(" - ")[0].split(" – ")[0].split(" — ")[0];
    t = t.replace(/\(.*?\)|\[.*?\]/g, "");
    t = t.replace(/[^a-z0-9\s]/g, "");
    t = t.replace(/\s+/g, " ").trim();
    return t;
  }

  function setStatus(t) { statusEl.textContent = t; }
  function setResult(t) { resultEl.textContent = t; }

  function updateUI() {
    roundLabel.textContent = `${round} / ${roundsTotal}`;
    scoreEl.textContent = score;

    loginBtn.textContent = isAuthed() ? "Re-login Spotify" : "Login Spotify";
    shuffleBtn.disabled = !deviceId;
    playBtn.disabled = !deviceId || !tracks.length || active || round >= roundsTotal;
    skipBtn.disabled = !active;
    guessEl.disabled = !active;
    submitBtn.disabled = !active;
    
    // Ensure input is focused when enabled
    if (active && !guessEl.disabled) {
      // Use setTimeout to ensure DOM has updated
      setTimeout(() => guessEl.focus(), 0);
    }
  }

  /* ---------------- spotify loaders ---------------- */

  async function transferPlayback() {
    try {
      await spotifyFetch("/me/player", {
        method: "PUT",
        body: { device_ids: [deviceId], play: false }
      });
      await sleep(1000); // Give more time for transfer
    } catch (e) {
      console.error("Transfer playback error:", e);
      throw new Error("Failed to transfer playback to browser. Make sure Spotify is not playing on another device.");
    }
  }

  async function loadTopTracks() {
    async function fetchRange(r) {
      const d = await spotifyFetch(`/me/top/tracks?limit=50&time_range=${r}`);
      return d.items.map(t => ({
        uri: t.uri,
        name: t.name,
        artist: t.artists[0]?.name || "",
        duration_ms: t.duration_ms
      }));
    }
    const all = [
      ...(await fetchRange("short_term")),
      ...(await fetchRange("medium_term")),
      ...(await fetchRange("long_term"))
    ];
    const seen = new Set();
    return all.filter(t => t.uri && !seen.has(t.uri) && seen.add(t.uri));
  }

  async function loadRandomTracks() {
    const me = await spotifyFetch("/me");
    const market = me?.country || "US";
    const letters = "abcdefghijklmnopqrstuvwxyz";
    const q = letters[Math.floor(Math.random() * letters.length)];
    const offset = Math.floor(Math.random() * 300);

    const d = await spotifyFetch(
      `/search?q=${encodeURIComponent(q)}&type=track&limit=50&offset=${offset}&market=${market}`
    );

    const seen = new Set();
    return (d.tracks.items || []).map(t => ({
      uri: t.uri,
      name: t.name,
      artist: t.artists[0]?.name || "",
      duration_ms: t.duration_ms
    })).filter(t => t.uri && t.duration_ms && !seen.has(t.uri) && seen.add(t.uri));
  }

  async function refreshPool() {
    setStatus(songPool === "top" ? "Loading your songs…" : "Loading random songs…");
    try {
      tracks = songPool === "top" ? await loadTopTracks() : await loadRandomTracks();
      setStatus(`Loaded ${tracks.length} songs (${songPool === "top" ? "Your songs" : "Random songs"}).`);
    } catch (e) {
      // Don't expose full error details to users
      setStatus("Failed to load songs. Please try again.");
      tracks = [];
    }
    updateUI();
  }

  /* ---------------- playback ---------------- */

  async function pausePlayback() {
    try {
      await spotifyFetch(`/me/player/pause?device_id=${deviceId}`, { method: "PUT" });
    } catch {}
  }

  function stopTimer() {
    if (timer) clearInterval(timer);
    timer = null;
  }

  function startTimer(ms) {
    let remaining = ms;
    timerEl.textContent = Math.ceil(remaining / 1000) + "s";
    stopTimer();
    timer = setInterval(async () => {
      remaining -= 250;
      timerEl.textContent = Math.max(0, Math.ceil(remaining / 1000)) + "s";
      if (remaining <= 0) {
        stopTimer();
        await pausePlayback();
        active = false;
        setResult(`⏰ Time! It was "${current.name}" — ${current.artist}`);
        updateUI();
      }
    }, 250);
  }

  async function playClip(track) {
    try {
      const clipMs = clipSeconds * 1000;
      const startMs = Math.floor(Math.random() * Math.max(1, track.duration_ms - clipMs));

      setStatus("Waiting for device to be ready…");
      await waitForActiveDevice();

      setStatus("Starting playback…");
      // Try to play the track
      let playSuccess = false;
      for (let i = 0; i < 3; i++) {
        try {
          await spotifyFetch(`/me/player/play?device_id=${deviceId}`, {
            method: "PUT",
            body: { uris: [track.uri] }
          });
          playSuccess = true;
          break;
        } catch (e) {
          if (i === 2) throw e; // Re-throw on last attempt
          await sleep(500);
        }
      }

      // Wait a bit for playback to start
      await sleep(500);
      
      // Seek to random position
      try {
        await spotifyFetch(`/me/player/seek?device_id=${deviceId}&position_ms=${startMs}`, { method: "PUT" });
      } catch (e) {
        console.warn("Seek failed, but continuing:", e);
      }

      startTimer(clipMs);
      setStatus("Playing…");
    } catch (e) {
      active = false;
      setStatus(`Playback error: ${e.message}`);
      updateUI();
      throw e;
    }
  }

  /* ---------------- game flow ---------------- */

  async function startRound() {
    setResult("");
    guessEl.value = "";
    round++;
    current = tracks[Math.floor(Math.random() * tracks.length)];
    active = true;
    updateUI();
    // Focus the input field immediately so user can start typing
    guessEl.focus();
    await playClip(current);
  }

  async function correctGuess() {
    stopTimer();
    await pausePlayback();
    score++;
    active = false;
    setResult(`✅ Correct! "${current.name}" — ${current.artist}`);
    updateUI();
  }

  async function skipRound() {
    stopTimer();
    await pausePlayback();
    active = false;
    setResult(`Skipped. It was "${current.name}" — ${current.artist}`);
    updateUI();
  }

  /* ---------------- buttons ---------------- */

  loginBtn.onclick = () => beginLogin({ force: true });
  quitBtn.onclick = () => location.href = "index.html";
  playBtn.onclick = startRound;
  skipBtn.onclick = skipRound;
  shuffleBtn.onclick = refreshPool;

  submitBtn.onclick = async () => {
    if (normalizeTitle(guessEl.value) === normalizeTitle(current.name)) {
      await correctGuess();
    } else {
      setResult("Not quite — keep guessing!");
      // Keep input enabled and focused for continued guessing
      if (active) {
        guessEl.focus();
        guessEl.select(); // Select text so user can type over it
      }
    }
  };

  guessEl.onkeydown = e => e.key === "Enter" && submitBtn.click();

  initBtn.onclick = async () => {
    if (!window.Spotify || !isAuthed()) return setStatus("Login first.");
    
    try {
      setStatus("Creating Spotify player…");
      initBtn.disabled = true;

      player = new Spotify.Player({
        name: "Guess The Song (Browser Player)",
        getOAuthToken: cb => {
          const token = getAccessToken();
          if (!token) {
            setStatus("Token expired. Please log in again.");
            cb(null);
          } else {
            cb(token);
          }
        },
        volume: 0.8
      });

      player.addListener("ready", async ({ device_id }) => {
        deviceId = device_id;
        setStatus("Player ready. Transferring playback…");
        try {
          await transferPlayback();
          await refreshPool();
          setStatus("Ready! Click 'Play Round' to start.");
        } catch (e) {
          setStatus(`Error: ${e.message}`);
          console.error("Player ready error:", e);
        }
      });

      player.addListener("not_ready", ({ device_id }) => {
        console.log("Device not ready:", device_id);
        setStatus("Device not ready. Please try again.");
        initBtn.disabled = false;
      });

      player.addListener("authentication_error", ({ message }) => {
        console.error("Authentication error:", message);
        setStatus("Authentication failed. Please log in again.");
        initBtn.disabled = false;
      });

      player.addListener("account_error", ({ message }) => {
        console.error("Account error:", message);
        setStatus("Account error. Please check your Spotify account.");
        initBtn.disabled = false;
      });

      player.addListener("playback_error", ({ message }) => {
        console.error("Playback error:", message);
        setStatus(`Playback error: ${message}`);
      });

      const connected = await player.connect();
      if (!connected) {
        setStatus("Failed to connect player. Please try again.");
        initBtn.disabled = false;
      }
    } catch (e) {
      setStatus(`Error initializing player: ${e.message}`);
      console.error("Init error:", e);
      initBtn.disabled = false;
    }
  };

  setStatus(isAuthed()
    ? `Logged in. Mode: ${songPool === "random" ? "Random songs" : "Your songs"}. Initialize the player.`
    : "Not logged in yet."
  );
  updateUI();
</script>
</body>
</html>
