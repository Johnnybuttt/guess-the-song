<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- CSP temporarily removed for debugging input issue -->
  <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://sdk.scdn.co; connect-src 'self' https://api.spotify.com https://accounts.spotify.com; style-src 'self' 'unsafe-inline';"> -->
  <title>Guess The Song</title>
  <link rel="stylesheet" href="app.css">
</head>
<body>
<div class="container">
  <h1>üéµ Guess The Song üéµ</h1>

  <div class="card">
    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">Round</div>
        <div class="stat-value" id="roundLabel">0 / 0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Time</div>
        <div class="stat-value" id="timer">‚Äî</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Score</div>
        <div class="stat-value" id="score">0</div>
      </div>
    </div>

    <div class="round-progress">
      <div class="round-progress-fill" id="roundProgress"></div>
    </div>

    <div class="controls">
      <button id="loginBtn" class="secondary">üîê Login Spotify</button>
      <button id="initBtn" class="primary" disabled>‚ñ∂Ô∏è Initialize Player</button>
      <button id="shuffleBtn" class="secondary" disabled>üîÄ Shuffle More</button>
      <button id="playBtn" class="primary" disabled>üéÆ Play Round</button>
      <button id="skipBtn" class="secondary" disabled>‚è≠Ô∏è Skip</button>
      <button id="quitBtn" class="secondary">‚öôÔ∏è Settings</button>
    </div>

    <div class="status" id="status">Ready to play!</div>

    <div class="now-playing" id="nowPlaying">
      <div class="now-playing-label">Now Playing</div>
      <div class="now-playing-title" id="nowTitle">‚Äî</div>
      <div class="now-playing-artist" id="nowArtist"></div>
    </div>

    <div class="guess-section">
      <div class="guess-input-wrapper">
        <input id="guess" type="text" placeholder="Type the song title here..." disabled autocomplete="off" tabindex="0">
        <button id="hintBtn" class="secondary" disabled>Hint</button>
        <button id="submit" class="primary" disabled>Submit</button>
      </div>
      <div class="result" id="result"></div>
    </div>
  </div>
</div>

<!-- Spotify SDK callback -->
<script>
  window.__sdkReady = false;
  window.onSpotifyWebPlaybackSDKReady = () => {
    window.__sdkReady = true;
    document.getElementById("initBtn").disabled = false;
    document.getElementById("status").textContent =
      "Spotify SDK loaded. Click Initialize Player.";
  };
</script>

<script src="https://sdk.scdn.co/spotify-player.js"></script>

<script type="module">
  import { beginLogin, isAuthed, getAccessToken, spotifyFetch } from "./spotify.js";

  const roundsTotal = Number(localStorage.getItem("rounds") || 10);
  const clipSeconds = Number(localStorage.getItem("clip") || 30);
  const songPool = localStorage.getItem("song_pool") || "top"; // top | random

  const loginBtn = document.getElementById("loginBtn");
  const initBtn = document.getElementById("initBtn");
  const shuffleBtn = document.getElementById("shuffleBtn");
  const playBtn = document.getElementById("playBtn");
  const skipBtn = document.getElementById("skipBtn");
  const quitBtn = document.getElementById("quitBtn");
  const statusEl = document.getElementById("status");
  const roundLabel = document.getElementById("roundLabel");
  const timerEl = document.getElementById("timer");
  const scoreEl = document.getElementById("score");
  const guessEl = document.getElementById("guess");
  const submitBtn = document.getElementById("submit");
  const hintBtn = document.getElementById("hintBtn");
  const resultEl = document.getElementById("result");
  const roundProgress = document.getElementById("roundProgress");
  const nowTitle = document.getElementById("nowTitle");
  const nowArtist = document.getElementById("nowArtist");

  let player, deviceId;
  let tracks = [], current = null;
  let round = 0, score = 0;
  let timer = null, active = false;
  let history = [];
  let hintUsedThisRound = false;
  let totalMsForRound = 0;
  let remainingMsForRound = 0;

  /* ---------------- helpers ---------------- */

  const sleep = ms => new Promise(r => setTimeout(r, ms));

  async function waitForActiveDevice(timeout = 4000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      try {
        const state = await spotifyFetch("/me/player");
        if (state?.device?.id === deviceId && state?.device?.is_active) return true;
      } catch {}
      await sleep(250);
    }
    return false;
  }

  function normalizeTitle(s) {
    let t = (s || "").toLowerCase().trim();
    t = t.split(" - ")[0].split(" ‚Äì ")[0].split(" ‚Äî ")[0];
    t = t.replace(/\(.*?\)|\[.*?\]/g, "");
    t = t.replace(/[^a-z0-9\s]/g, "");
    t = t.replace(/\s+/g, " ").trim();
    return t;
  }

  function setStatus(t) { 
    statusEl.textContent = t;
    // Add playing animation when music is playing
    if (active && t.includes("Playing")) {
      statusEl.classList.add("playing");
    } else {
      statusEl.classList.remove("playing");
    }
  }
  
  function setResult(t, type = "") { 
    resultEl.textContent = t;
    resultEl.className = "result";
    if (type === "correct") {
      resultEl.classList.add("correct");
    } else if (type === "incorrect") {
      resultEl.classList.add("incorrect");
    } else if (type === "timeout") {
      resultEl.classList.add("timeout");
    }
  }

  function updateUI() {
    roundLabel.textContent = `${round} / ${roundsTotal}`;
    scoreEl.textContent = score;

    const progress = roundsTotal ? Math.min(1, round / roundsTotal) : 0;
    roundProgress.style.width = `${progress * 100}%`;

    // Update timer display - show "‚Äî" when not active
    if (!active && !timer) {
      timerEl.textContent = "‚Äî";
    }

    loginBtn.textContent = isAuthed() ? "üîê Re-login Spotify" : "üîê Login Spotify";
    shuffleBtn.disabled = !deviceId;
    playBtn.disabled = !deviceId || !tracks.length || active || round >= roundsTotal;
    skipBtn.disabled = !active;
    guessEl.disabled = !active;
    submitBtn.disabled = !active;
    hintBtn.disabled = !active;
  }

  /* ---------------- spotify loaders ---------------- */

  async function transferPlayback() {
    await spotifyFetch("/me/player", {
      method: "PUT",
      body: { device_ids: [deviceId], play: false }
    });
    await sleep(500);
  }

  async function loadTopTracks() {
    // Dev mode uses mock data from spotify.js
    const devMode = new URLSearchParams(window.location.search).get('dev') === 'true' 
      || localStorage.getItem('dev_mode') === 'true';
    if (devMode) {
      const data = await spotifyFetch("/me/top/tracks?limit=50&time_range=medium_term");
      return data.items.map(t => ({
        uri: t.uri,
        name: t.name,
        artist: t.artists[0]?.name || "",
        duration_ms: t.duration_ms
      }));
    }
    
    async function fetchRange(r) {
      const d = await spotifyFetch(`/me/top/tracks?limit=50&time_range=${r}`);
      return d.items.map(t => ({
        uri: t.uri,
        name: t.name,
        artist: t.artists[0]?.name || "",
        duration_ms: t.duration_ms
      }));
    }
    const all = [
      ...(await fetchRange("short_term")),
      ...(await fetchRange("medium_term")),
      ...(await fetchRange("long_term"))
    ];
    const seen = new Set();
    return all.filter(t => t.uri && !seen.has(t.uri) && seen.add(t.uri));
  }

  async function loadRandomTracks() {
    // Dev mode uses mock data from spotify.js
    const devMode = new URLSearchParams(window.location.search).get('dev') === 'true' 
      || localStorage.getItem('dev_mode') === 'true';
    if (devMode) {
      const data = await spotifyFetch("/search?q=a&type=track&limit=50");
      const seen = new Set();
      return (data.tracks.items || []).map(t => ({
        uri: t.uri,
        name: t.name,
        artist: t.artists[0]?.name || "",
        duration_ms: t.duration_ms
      })).filter(t => t.uri && t.duration_ms && !seen.has(t.uri) && seen.add(t.uri));
    }
    const me = await spotifyFetch("/me");
    const market = me?.country || "US";
    const letters = "abcdefghijklmnopqrstuvwxyz";
    const q = letters[Math.floor(Math.random() * letters.length)];
    const offset = Math.floor(Math.random() * 300);

    const d = await spotifyFetch(
      `/search?q=${encodeURIComponent(q)}&type=track&limit=50&offset=${offset}&market=${market}`
    );

    const seen = new Set();
    return (d.tracks.items || []).map(t => ({
      uri: t.uri,
      name: t.name,
      artist: t.artists[0]?.name || "",
      duration_ms: t.duration_ms
    })).filter(t => t.uri && t.duration_ms && !seen.has(t.uri) && seen.add(t.uri));
  }

  async function refreshPool() {
    setStatus(songPool === "top" ? "Loading your songs‚Ä¶" : "Loading random songs‚Ä¶");
    try {
      tracks = songPool === "top" ? await loadTopTracks() : await loadRandomTracks();
      setStatus(`Loaded ${tracks.length} songs (${songPool === "top" ? "Your songs" : "Random songs"}).`);
    } catch (e) {
      setStatus("Load failed: " + e.message);
      tracks = [];
    }
    updateUI();
  }

  /* ---------------- playback ---------------- */

  async function pausePlayback() {
    const devMode = new URLSearchParams(window.location.search).get('dev') === 'true' 
      || localStorage.getItem('dev_mode') === 'true';
    if (devMode) return; // No-op in dev mode
    
    try {
      await spotifyFetch(`/me/player/pause?device_id=${deviceId}`, { method: "PUT" });
    } catch {}
  }

  function stopTimer() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }

  function startTimer(ms) {
    stopTimer(); // Clear any existing timer first
    totalMsForRound = ms;
    remainingMsForRound = ms;
    
    // Update display immediately
    const updateDisplay = () => {
      const seconds = Math.max(0, Math.ceil(remainingMsForRound / 1000));
      timerEl.textContent = seconds + "s";
    };
    
    updateDisplay();
    
    // Update every 100ms for smoother countdown
    timer = setInterval(() => {
      remainingMsForRound -= 100;
      
      if (remainingMsForRound <= 0) {
        remainingMsForRound = 0;
        stopTimer();
        updateDisplay();
        
        // Handle timeout
        (async () => {
          await pausePlayback();
          active = false;
          setResult(`‚è∞ Time's up! It was "${current.name}" by ${current.artist}`, "timeout");
          setStatus(""); // Clear hint message
          history.push({ track: current, result: "timeout", hint: hintUsedThisRound });
          updateUI();
          maybeEndGame();
        })();
      } else {
        updateDisplay();
      }
    }, 100);
  }

  async function playClip(track) {
    const devMode = new URLSearchParams(window.location.search).get('dev') === 'true' 
      || localStorage.getItem('dev_mode') === 'true';
    
    if (devMode) {
      // Dev mode: Just start the timer, no actual playback
      const clipMs = clipSeconds * 1000;
      setStatus("üéµ Playing (dev mode - no audio)‚Ä¶");
      startTimer(clipMs);
      return;
    }
    
    const clipMs = clipSeconds * 1000;
    const startMs = Math.floor(Math.random() * Math.max(1, track.duration_ms - clipMs));

    await waitForActiveDevice();

    for (let i = 0; i < 2; i++) {
      try {
        await spotifyFetch(`/me/player/play?device_id=${deviceId}`, {
          method: "PUT",
          body: { uris: [track.uri] }
        });
        break;
      } catch {
        await sleep(350);
      }
    }

    await sleep(350);
    await spotifyFetch(`/me/player/seek?device_id=${deviceId}&position_ms=${startMs}`, { method: "PUT" });

    startTimer(clipMs);
  }

  /* ---------------- game flow ---------------- */

  async function startRound() {
    stopTimer(); // Make sure any previous timer is cleared
    setResult("");
    setStatus(""); // Clear any previous status messages (like hint messages)
    guessEl.value = "";
    round++;
    current = tracks[Math.floor(Math.random() * tracks.length)];
    active = true;
    hintUsedThisRound = false;
    nowTitle.textContent = "Guess the song!";
    nowArtist.textContent = songPool === "random" ? "Random track" : "From your library";
    updateUI();
    await playClip(current);
  }

  async function correctGuess() {
    stopTimer();
    await pausePlayback();

    // Time-based scoring: base 100 + up to 50 bonus for fast guesses
    let gained = 100;
    if (totalMsForRound > 0 && remainingMsForRound > 0) {
      const ratio = Math.max(0, Math.min(1, remainingMsForRound / totalMsForRound));
      gained += Math.round(50 * ratio);
    }
    // Penalty for using hint
    if (hintUsedThisRound) {
      gained = Math.max(50, gained - 40);
    }

    score += gained;
    active = false;
    setResult(`‚úÖ Correct! "${current.name}" by ${current.artist} (+${gained} pts)`, "correct");
    setStatus(""); // Clear hint message
    nowTitle.textContent = current.name;
    nowArtist.textContent = current.artist;
    history.push({ track: current, result: "correct", hint: hintUsedThisRound, points: gained });
    updateUI();
    maybeEndGame();
  }

  async function skipRound() {
    stopTimer();
    await pausePlayback();
    active = false;
    setResult(`‚è≠Ô∏è Skipped. It was "${current.name}" by ${current.artist}`);
    setStatus(""); // Clear hint message
    updateUI();
    history.push({ track: current, result: "skipped", hint: hintUsedThisRound });
    maybeEndGame();
  }

  function maybeEndGame() {
    if (round < roundsTotal) return;

    active = false;
    stopTimer();
    updateUI();

    const totalRoundsPlayed = history.length;
    const correctCount = history.filter(h => h.result === "correct").length;
    const accuracy = totalRoundsPlayed ? Math.round((correctCount / totalRoundsPlayed) * 100) : 0;
    const totalPoints = history.reduce((sum, h) => sum + (h.points || 0), 0);

    let summary = `Game over! You scored ${totalPoints} pts.\n\n` +
      `Rounds played: ${totalRoundsPlayed}\n` +
      `Correct: ${correctCount}\n` +
      `Accuracy: ${accuracy}%\n\n` +
      `Songs this game:\n`;

    history.forEach((h, i) => {
      summary += `${i + 1}. ${h.track.name} ‚Äî ${h.track.artist} (${h.result}${h.hint ? ", used hint" : ""})\n`;
    });

    resultEl.className = "result";
    resultEl.textContent = summary;

    setStatus("Game over. Play again or change settings.");
    playBtn.textContent = "üîÅ Play Again";
    playBtn.disabled = false;
    playBtn.onclick = () => {
      window.location.href = "index.html";
    };
  }

  /* ---------------- buttons ---------------- */

  loginBtn.onclick = () => beginLogin({ force: true });
  quitBtn.onclick = () => location.href = "index.html";
  playBtn.onclick = startRound;
  skipBtn.onclick = skipRound;
  shuffleBtn.onclick = refreshPool;

  submitBtn.onclick = async () => {
    if (normalizeTitle(guessEl.value) === normalizeTitle(current.name)) {
      await correctGuess();
    } else {
      setResult("‚ùå Not quite ‚Äî keep guessing!", "incorrect");
    }
  };

  hintBtn.onclick = () => {
    if (!active || !current) return;
    if (hintUsedThisRound) {
      setStatus("Hint already used for this round.");
      return;
    }
    hintUsedThisRound = true;
    nowArtist.textContent = current.artist;
    setStatus("Hint: Artist revealed. Fewer points for this round.");
  };

  // Debug: Add input event listeners to diagnose the issue
  guessEl.oninput = e => {
    console.log('Input event:', e.target.value);
  };
  
  guessEl.onkeydown = e => {
    console.log('Keydown event:', e.key, 'Value:', e.target.value);
    if (e.key === "Enter") submitBtn.click();
  };
  
  guessEl.onkeyup = e => {
    console.log('Keyup event:', e.key, 'Value:', e.target.value);
  };

  initBtn.onclick = async () => {
    // Check for dev mode
    const devMode = new URLSearchParams(window.location.search).get('dev') === 'true' 
      || localStorage.getItem('dev_mode') === 'true';
    
    if (devMode) {
      // Dev mode: Skip Spotify SDK, just set deviceId
      deviceId = "dev-device";
      setStatus("Dev mode active. Loading mock tracks‚Ä¶");
      await refreshPool();
      setStatus("Ready! Click 'Play Round' to start.");
      updateUI();
      return;
    }
    
    if (!window.Spotify || !isAuthed()) return setStatus("Login first.");
    setStatus("Creating Spotify player‚Ä¶");

    player = new Spotify.Player({
      name: "Guess The Song (Browser Player)",
      getOAuthToken: cb => cb(getAccessToken()),
      volume: 0.8
    });

    player.addListener("ready", async ({ device_id }) => {
      deviceId = device_id;
      setStatus("Player ready. Transferring playback‚Ä¶");
      await transferPlayback();
      await refreshPool();
    });

    await player.connect();
  };

  // Check for dev mode
  const devMode = new URLSearchParams(window.location.search).get('dev') === 'true' 
    || localStorage.getItem('dev_mode') === 'true';
  
  if (devMode) {
    setStatus("üîß DEV MODE ACTIVE - No Spotify login required!");
    initBtn.disabled = false;
  } else {
    setStatus(isAuthed()
      ? `Logged in. Mode: ${songPool === "random" ? "Random songs" : "Your songs"}. Initialize the player.`
      : "Not logged in yet."
    );
  }
  updateUI();
</script>
</body>
</html>
